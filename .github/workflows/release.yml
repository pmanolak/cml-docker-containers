name: Release

permissions:
  contents: write
  actions: read

on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      build_run_id:
        description: 'Optional Run ID of the build that produced artifacts (artifact name is deb-artifacts-<run_id>)'
        required: false
        default: ''
      use_latest:
        description: 'If true and no build_run_id provided, use latest successful build'
        required: false
        default: 'false'
      release_tag:
        description: 'Optional release tag to use when creating a release'
        required: false
        default: ''
      release_name:
        description: 'Optional release name'
        required: false
        default: ''

jobs:
  release:
    name: Sign artifacts and create GitHub Release
    runs-on: ubuntu-24.04
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout (for helper scripts)
        uses: actions/checkout@v4

      - name: Find build for tag and download artifacts
        id: fetch_artifacts
        run: |
          set -euo pipefail
          mkdir -p artifacts

          # Ensure gh and jq are available
          if ! command -v gh >/dev/null 2>&1; then
            echo "Installing gh CLI..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod 644 /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update && sudo apt-get install -y gh
          fi
          if ! command -v jq >/dev/null 2>&1; then
            echo "Installing jq..."
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # Determine context: tag push or manual dispatch with release_tag
          if [ -n "${GITHUB_REF:-}" ] && [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            COMMIT="${GITHUB_SHA}"
            echo "Release triggered by tag push: tag=$TAG commit=$COMMIT"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.release_tag }}" ]; then
            TAG="${{ inputs.release_tag }}"
            # Pick dispatch branch, fallback to main
            BRANCH="${{ github.ref_name }}"; [ -n "$BRANCH" ] || BRANCH="main"
            echo "Manual dispatch: creating/using tag '${TAG}' on branch '${BRANCH}'"

            # Resolve branch head commit SHA using gh
            COMMIT="$(gh api "repos/${GITHUB_REPOSITORY}/git/refs/heads/${BRANCH}" --jq '.object.sha')"
            if [ -z "${COMMIT}" ] || [ "${COMMIT}" = "null" ]; then
              echo "Error: failed to resolve head commit for branch '${BRANCH}'" >&2
              exit 1
            fi

            # Create the tag if it does not yet exist (using gh)
            if gh api "repos/${GITHUB_REPOSITORY}/git/refs/tags/${TAG}" >/dev/null 2>&1; then
              echo "Tag '${TAG}' already exists; continuing"
            else
              echo "Creating tag refs/tags/${TAG} -> ${COMMIT}"
              gh api "repos/${GITHUB_REPOSITORY}/git/refs" \
                -f ref="refs/tags/${TAG}" \
                -f sha="${COMMIT}" >/dev/null
            fi
          else
            echo "Not a tag push and no release_tag provided; aborting."
            exit 1
          fi

          # Find a successful build run for this commit using the REST API
          RUN_ID=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/workflows/build.yml/runs?per_page=100" \
            | jq -r --arg COMMIT "${COMMIT}" '.workflow_runs | map(select(.head_sha==$COMMIT and .conclusion=="success")) | .[0].id')

          if [ -z "${RUN_ID}" ] || [ "${RUN_ID}" = "null" ]; then
            echo "Error: no successful build run found for commit ${COMMIT}. Aborting release."
            echo "Ensure a successful build for this commit exists (CI on main) before pushing the tag."
            exit 1
          fi

          echo "Found build run id: ${RUN_ID}"
          ARTIFACT_NAME="deb-artifacts-${RUN_ID}"
          echo "Looking for artifact: ${ARTIFACT_NAME}"

          # Find artifact id via REST API
          ARTIFACT_ID=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts?per_page=100" \
            | jq -r --arg NAME "${ARTIFACT_NAME}" '.artifacts | map(select(.name==$NAME)) | .[0].id')

          if [ -z "${ARTIFACT_ID}" ] || [ "${ARTIFACT_ID}" = "null" ]; then
            echo "Error: artifact ${ARTIFACT_NAME} not found for run ${RUN_ID}. Aborting."
            exit 1
          fi

          echo "Found artifact id: ${ARTIFACT_ID}; downloading..."
          curl -L -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts/${ARTIFACT_ID}/zip" -o artifact.zip
          unzip -q artifact.zip -d artifacts
          rm -f artifact.zip
          echo "Artifacts available under ./artifacts"

      - name: List downloaded artifacts
        run: |
          echo "Artifacts in ./artifacts:"
          ls -la artifacts || true

      - name: "Log: tag push detected"
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          echo "Tag push detected: ${GITHUB_REF#refs/tags/} â€” proceeding with release"

      - name: "Log: manual run detected"
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Manual workflow_dispatch run - proceeding with release"

      - name: Import GPG key
        id: import_gpg
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}

      - name: Install signing tools and ensure gh CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends gnupg2 curl devscripts || true
          # gh should already be present from the earlier step
          gh --version

      - name: Create detached ASCII signatures for artifacts
        env:
          GPG_FPR: ${{ steps.import_gpg.outputs.fingerprint }}
          PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cd artifacts
          export GNUPGHOME="${GNUPGHOME:-$HOME/.gnupg}"
          chmod 700 "$GNUPGHOME" || true

          for f in *.deb *.changes *.buildinfo docker-refplat-images-*.tar.gz docker-refplat-images-*.iso; do
            [ -f "$f" ] || continue
            echo "Signing $f -> ${f}.asc"
            gpg --batch --yes --pinentry-mode loopback \
                --passphrase "${PASSPHRASE}" \
                --local-user "${GPG_FPR}" \
                --armor --output "${f}.asc" --detach-sign "$f"
          done

      - name: Debian-style sign .changes with debsign
        # if: always()
        # if: true
        env:
          GPG_FPR: ${{ steps.import_gpg.outputs.fingerprint }}
        run: |
          set -euo pipefail
          cd artifacts
          if command -v debsign >/dev/null 2>&1; then
            for ch in *.changes; do
              [ -f "$ch" ] || continue
              echo "Attempting debsign on $ch (debian-style signature)"
              debsign -k"${GPG_FPR}" "$ch" || echo "debsign failed for $ch; skipping debsign"
            done
          else
            echo "debsign not installed; skipping Debian-native signing"
          fi

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd artifacts

          # determine tag to use (prefer the pushed tag, then input, then build-run fallback)
          if [ -n "${GITHUB_REF:-}" ] && [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            tag="${GITHUB_REF#refs/tags/}"
          elif [ -n "${RELEASE_TAG:-}" ]; then
            tag="${RELEASE_TAG}"
          elif [ -n "${{ inputs.release_tag }}" ]; then
            tag="${{ inputs.release_tag }}"
          elif [ -n "${BUILD_RUN_ID:-}" ]; then
            tag="build-${BUILD_RUN_ID}"
          else
            echo "Error: no tag found or provided. Set inputs.release_tag, push a tag, or provide build_run_id." >&2
            exit 1
          fi

          # sanity check tag format: non-empty, no whitespace
          if [[ -z "${tag// /}" ]]; then
            echo "Error: computed tag is empty or contains only whitespace" >&2
            exit 1
          fi

          name="${{ inputs.release_name }}"
          [ -n "$name" ] || name="Automated release ${tag}"
          body="Automated release for build run ${{ inputs.build_run_id }}"

          # Create release idempotently via gh; skip if it exists
          if gh release view "${tag}" >/dev/null 2>&1; then
            echo "Release '${tag}' already exists; continuing"
          else
            echo "Creating release ${tag}"
            gh release create "${tag}" --title "${name}" --notes "${body}"
          fi
          # Export tag for upload step
          echo "RELEASE_TAG=${tag}" >> $GITHUB_ENV

      - name: Upload individual artifacts via gh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd artifacts
          for f in *.deb *.changes *.buildinfo docker-refplat-images-*.tar.gz docker-refplat-images-*.iso *.asc; do
            [ -f "$f" ] || continue
            echo "Uploading $f via gh release upload"
            gh release upload "${RELEASE_TAG}" "$f" || echo "upload failed for $f"
          done
